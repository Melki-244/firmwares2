#!/bin/sh

##############################################################################
#
# INTEL CONFIDENTIAL
# Copyright (c) 2016 Intel Corporation All Rights Reserved
#
# The source code contained or described herein and all documents related
# to the source code ("Material") are owned by Intel Corporation or its
# suppliers or licensors. Title to the Material remains with Intel
# Corporation or its suppliers and licensors. The Material contains trade
# secrets and proprietary and confidential information of Intel or its
# suppliers and licensors. The Material is protected by worldwide copyright
# and trade secret laws and treaty provisions. No part of the Material may
# be used, copied, reproduced, modified, published, uploaded, posted,
# transmitted, distributed, or disclosed in any way without Intel's prior
# express written permission.
#
# No license under any patent, copyright, trade secret or other intellectual
# property right is granted to or conferred upon you by disclosure or
# delivery of the Materials, either expressly, by implication, inducement,
# estoppel or otherwise. Any license under such intellectual property rights
# must be express and approved by Intel in writing.
#
##############################################################################

# This file "Takes care of" the log files generated by the shg modules
#
# Author : Eswar
# Date   : 29-oct-15

. /etc/shgw/shgw.constants

########################## GLOBALS ##########################################

LOCK_FILE=${SHGW_TMPFS_PATH}/shgw_rotate.lock
TEMP_FILE=${SHGW_TMPFS_PATH}/log


URL=$($ECHO "select primary_url from csp_service_discovery where service ='log_upload_url';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$URL" == "" ] && URL=NA

ACCESS_TOKEN=$($ECHO "select value from shgw_config_store where key = 'access_token';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$ACCESS_TOKEN" == "" ] && ACCESS_TOKEN=NA


# The regexes for filtering sensitivity level
SENSITIVITY0=/H\|M\|L/
SENSITIVITY1=/M\|L/
SENSITIVITY2=/L/

########################## Functions ##########################################

exit_if_running() {
	exec 200>$LOCK_FILE
	flock -nx 200 || exit 1
}

clear_file() {
	# $1 : file name
	# $2 : extension
	#
	# if the file extension is more than 0 then delete otherwise just empty the file
	local file_name=$1
	local extension=$2

	[ "$extension" == "0" ] && $ECHO '' > $file_name && return
	$RM -rf $file_name
}

# upload not implemented
handle_stale_file() {
	# $1 : File name
	# $2 : {delete, upload}
	# $3 : sensitivity_level for upload filter
	# $4 : extension
	local file_name=$1
	local strategy=$2
	local extension=$4
	local clear_file_contents=0

	[ X"$strategy" == X"delete" ] && clear_file $file_name $extension && return

	local sensitivity_level=$3

	# Set the defaults if the conf is not in legal range
	[ "$sensitivity_level" -lt "0" 2>/dev/null ] ||
	[ "$sensitivity_level" -gt "2" 2>/dev/null ] && sensitivity_level=2

	local sensitivity_regex=$(eval $ECHO \$SENSITIVITY$sensitivity_level)

	$($AWK '$5 ~ '"$sensitivity_regex"' {print}' $file_name > $TEMP_FILE)

	# Upload only if the URL and Access Token are available
	[ "$URL" != "NA" -a "$ACCESS_TOKEN" != "NA" ] &&
	$CURL -H "Authorization: $ACCESS_TOKEN"              \
		  -H "Content-Type:multipart/form-data"  \
		  -F "file[]=@$TEMP_FILE"                \
		  -X POST                                \
		  --"$CACERT" "$CA_CERT_FILE"     \
		  $URL 2>/dev/null 1>/dev/null         &&
	clear_file_contents=1

	[ "$clear_file_contents" == "1" ] && clear_file $file_name $extension
	$RM -rf $TEMP_FILE
}

get_file_size() {
	size=$($LS -l $1 2>/dev/null | $AWK '{ print $'"$LS_FILE_SIZE_FIELD"' }')
	[ "$?" -eq "0" ] && $ECHO "$size"
}

rotate_log() {
	[ $# -ne 5 ] && $ECHO "Not enough params for rotate check your config file" &&  return
	local file=$1
	local size=$2
	local rotate_limit=$3
	local rotate_strategy=$4
	local sensitivity_level=$5
	local i
	local temp

	# Temp used to store the highest log extension below the legal limit
	local legal_oldest=0

	# Temp variable used to store the extensions of file like 1 in log.1
	local extension=0

	# check the file size and return if small file present
	local current_file_size=$(get_file_size "$file")

	[ "${current_file_size:-0}" -lt "$size" ]            &&
	$ECHO "Skipping rotate for $file insufficient size"  &&
	return

	# Find the biggest extension within the legal rotate limit
	for i in $($LS -la "$file".* 2>/dev/null | $AWK '{print $'"$LS_FILE_NAME_FIELD"'}') ; do
		extension=$($ECHO $i | $SED 's,'"$file"'.,,')

		[ "$extension" -ge "$rotate_limit" 2>/dev/null ] &&
		handle_stale_file $file.$extension $rotate_strategy $sensitivity_level $extension

		[ "$extension" -le "$rotate_limit" 2>/dev/null ] &&
		[ "$extension" -gt "$legal_oldest" ]             &&
		legal_oldest=$extension
	done

	temp=$legal_oldest

	# Move files to next version starting from biggest
	while [[ "$temp" -ge "0" ]]; do
		local next=$(($temp+1))
		[ -f $file.$temp ] && [ "$next" -le "$rotate_limit" ] && $CP $file.$temp $file.$next
		[ ! -f $file.$temp -a   "$next" -le "$rotate_limit" ] && $ECHO "File not found" > $file.$next
		temp=$(($temp-1))
	done

	[ "$rotate_limit" -gt "0" ] && $CP "$file" "$file".1 && $ECHO '' > "$file"
	[ "$rotate_limit" -gt "0" ] || handle_stale_file $file $rotate_strategy $sensitivity_level 0
}

# If line starts with a '#' then it is a comment.
read_conf_and_invoke_rotate_or_die() {
	
FILE_NAME=$($ECHO "select value from shgw_config_store where key = 'File_name';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$FILE_NAME" == "" ] && FILE_NAME=NA

FILE_SIZE=$($ECHO "select value from shgw_config_store where key = 'File_size';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$FILE_SIZE" == "" ] && FILE_SIZE=NA

ROTATE_LIMIT=$($ECHO "select value from shgw_config_store where key = 'Rotate_limit';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$ROTATE_LIMIT" == "" ] && ROTATE_LIMIT=NA

ROTATE_STRATEGY=$($ECHO "select value from shgw_config_store where key = 'Rotate_strategy';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$ROTATE_STRATEGY" == "" ] && ROTATE_STRATEGY=NA

SENSITIVITY_LEVEL=$($ECHO "select value from shgw_config_store where key = 'Sensitivity_level';" | $SQLITE $SHGW_PERSISTANT_DB)
[ "$?" != "0" -o "$SENSITIVITY_LEVEL" == "" ] && SENSITIVITY_LEVEL=NA

rotate_log $FILE_NAME $FILE_SIZE $ROTATE_LIMIT $ROTATE_STRATEGY $SENSITIVITY_LEVEL

}

########################## Driver code #######################################

exit_if_running
read_conf_and_invoke_rotate_or_die

########################## The end ##########################################
